"""
Plotting module containing functions to plot various graphs in astrophysics.

:title: plot.py

:author: Mitchell Shahen

:history: 02/05/2021
"""

import matplotlib.pyplot as plt
import numpy
import sys
sys.path.append("../") # be able to access the base directory

from base.constants import L_sun, M_sun, r_sun, rho_0_sun, T_0_sun, T_sun
from base.util import normalize_data


# ---------- # ANCILLARY PLOTTING FUNCTIONS # ---------- #

def _shade_convective(x_data=None, is_convective=None):
    """
    Function to use an array of True/False booleans to shade sections of a plot. A value of
    `True` in the `is_convective` array indicates that the background at the corresponding
    `x_data` point is to be shaded.

    :param x_data: An array of x-axis data points.
    :param is_convective: An array of True/False booleans of the same shape as `x_data`.
    """

    # iterate through the x-axis data and add shading to the appropriate regions
    for i, x in enumerate(x_data):
        # check that the is_convective array has designated this data point to be shaded
        if is_convective[i]:
            # exclude the last value to avoid an IndexError
            if i != len(x_data) - 1:
                # add the shading between the current data point and the next
                plt.axvspan(x, x_data[i + 1], facecolor="gray", alpha=0.2)


# ---------- # ASTROPHYSICAL PLOTTING FUNCTIONS # ---------- #

def hr_diagram(effect_temps, luminosities):
    """
    Function to plot a Hertzsprung-Russell diagram, that is a plot of effective surface temperature
    against relative luminosity. The effective surface temperature is in Kelvin and the luminosity
    is relative to the Sun's luminosity. The luminosity is also commonly given as a logarithm.

    :param effect_temps: An array of effective surface temperatures for many stars.
    :param luminosities: An array of non-normalized luminosities for many stars.
    """

    # normalize the luminosities with the Sun's luminosity
    norm_luminosities = normalize_data(
        in_data=numpy.array([luminosities]),
        norm_values=[L_sun]
    )

    # set the plot size
    plt.figure(figsize=(10, 8))

    # plot the effective surface temperatures against the stellar luminosities
    plt.plot(effect_temps, norm_luminosities, color="black", linestyle="solid")

    # set the labels for the x-axis and y-axis
    plt.xlabel("Effective Surface Temperature (in Kelvin)")
    plt.ylabel(r'Relative Luminosity ($L / L_{\circ}$)')

    # invert the x-axis so it is decreasing in temperature going left to right
    plt.gca().invert_xaxis()

    # set the x-axis (effective surface temperatures) to be logarithmic
    plt.xscale("log")

    # set the y-axis (relative luminosities) to be logarithmic
    plt.yscale("log")

    # set the title
    plt.title("Hertzsprung-Russell Diagram")

    # render the plot
    plt.show()


def luminosity_contribution_plot(stellar_structure, radius, density, temperature, mass, luminosity):
    """
    Function to plot the total luminosity as well as the luminosity generated by each
    non-negligible energy generation rate. Such energy generation rates include the
    PP-chain and the CNO cycle.

    :param stellar_structure: A module containing the relevant StellarStructure class
        containing the stellar structure equations.
    :param radius: An array of radius values.
    :param density: An array of density values.
    :param temperature: An array of temperature values.
    """

    # extract the StellarStructure class from the inputted `stellar_structure` parameter
    StellarStructure = stellar_structure.StellarStructure()

    # ---------- # CALCULATE THE LUMINOSITY CONTRIBUTIONS # ---------- #

    # get the energy generation rate for the PP-chain
    epsilon_pp = StellarStructure.pp_chain_energy(
        rho=density,
        T=temperature
    )

    # get the energy generation rate for the CNO cycle
    epsilon_cno = StellarStructure.cno_cycle_energy(
        rho=density,
        T=temperature,
        X_cno=None
    )

    # calculate the luminosity gradient using only the PP-chain
    pp_chain_lumin_grad = StellarStructure.energy_equation(
        r=radius,
        rho=density,
        T=temperature,
        energy_gen=epsilon_pp
    )

    # calculate the luminosity gradient using only the CNO cycle
    cno_cycle_lumin_grad = StellarStructure.energy_equation(
        r=radius,
        rho=density,
        T=temperature,
        energy_gen=epsilon_cno
    )

    # calculate the luminosity gradient from the total energy generation rate
    total_lumin_grad = StellarStructure.energy_equation(
        r=radius,
        rho=density,
        T=temperature,
        energy_gen=None
    )

    # ---------- # NORMALIZE THE RADIUS DATASET # ---------- #

    # normalize the radius data with the surface radius
    surf_radius = radius[-1]
    norm_radius = normalize_data(
        in_data=numpy.array([radius]),
        norm_values=[surf_radius]
    )

    # ---------- # DETERMINE THE CONVECTIVE REGIONS # ---------- #

    # iterate through the stellar properties obtaining the convective
    # and radiative temperatures at each radius value
    is_convective_list = []
    for i, radius_value in enumerate(radius):
        is_conv_value = StellarStructure.is_convective(
            radius_value,
            density[i],
            temperature[i],
            mass[i],
            luminosity[i]
        )

        is_convective_list.append(is_conv_value)

    # convert the lists of temperature values to arrays
    is_convective = numpy.array(is_convective_list)

    # ---------- # PLOTTING FUNCTIONS # ---------- #

    # set the plot size
    plt.figure(figsize=(10, 8))

    # plot each of the calculated and normalized pressures
    plt.plot(
        norm_radius,
        pp_chain_lumin_grad,
        label=r'$dL_{pp}/dr$',
        color="blue",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        cno_cycle_lumin_grad,
        label=r'$dL_{cno}/dr$',
        color="red",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        total_lumin_grad,
        label=r'$dL/dr$',
        color="black",
        linestyle="dashed"
    )

    # shade the convective regions
    _shade_convective(x_data=norm_radius, is_convective=is_convective)

    # set the title
    plt.title("Luminosity Contributions Plot")

    # set the xlabel
    plt.xlabel(r'Relative Radius ($r / R_{\star}$)')

    # set the ylabel
    plt.ylabel(r'Differential Luminosity ($dL/dr$)')

    # set the legend
    plt.legend()

    # render the plot
    plt.show()


def opacity_contribution_plot(stellar_structure, radius, density, temperature, mass, luminosity):
    """
    Function to plot the mean opacity and each opacity value that contributed to the
    mean opacity calculation.

    :param stellar_structure: A module containing the relevant StellarStructure class
        containing the stellar structure equations.
    :param radius: An array of radius values.
    :param density: An array of density values.
    :param temperature: An array of temperature values.
    """

    # extract the StellarStructure class from the inputted `stellar_structure` parameter
    StellarStructure = stellar_structure.StellarStructure()

    # ---------- # CALCULATE THE OPACITY CONTRIBUTIONS # ---------- #

    kappa_es_list = []
    kappa_ff_list = []
    kappa_hm_list = []
    mean_opacity_list = []

    # calculate the opacity components and mean opacity at each radius value
    for i, radius_value in enumerate(radius):
        # calculate each opacity value
        kappa_es = StellarStructure.opacity_e_scatter()
        kappa_ff = StellarStructure.opacity_ff_scatter(rho=density[i], T=temperature[i])
        kappa_hm = StellarStructure.opacity_hm_scatter(rho=density[i], T=temperature[i])
        mean_opacity = StellarStructure.mean_opacity(rho=density[i], T=temperature[i])

        # apply the logarithm to each of the calculated opacity values (base-10)
        log_kappa_es = numpy.log10(kappa_es)
        log_kappa_ff = numpy.log10(kappa_ff)
        log_kappa_hm = numpy.log10(kappa_hm)
        log_mean_opacity = numpy.log10(mean_opacity)

        # add each opacity value to its corresponding list
        kappa_es_list.append(log_kappa_es)
        kappa_ff_list.append(log_kappa_ff)
        kappa_hm_list.append(log_kappa_hm)
        mean_opacity_list.append(log_mean_opacity)

    # convert each opacity list to an array
    kappa_es_arr = numpy.array(kappa_es_list)
    kappa_ff_arr = numpy.array(kappa_ff_list)
    kappa_hm_arr = numpy.array(kappa_hm_list)
    mean_opacity_arr = numpy.array(mean_opacity_list)

    # ---------- # NORMALIZE THE RADIUS DATASET # ---------- #

    # normalize the radius data with the surface radius
    surf_radius = radius[-1]
    norm_radius = normalize_data(
        in_data=numpy.array([radius]),
        norm_values=[surf_radius]
    )

    # ---------- # DETERMINE THE CONVECTIVE REGIONS # ---------- #

    # iterate through the stellar properties obtaining the convective
    # and radiative temperatures at each radius value
    is_convective_list = []
    for i, radius_value in enumerate(radius):
        is_conv_value = StellarStructure.is_convective(
            radius_value,
            density[i],
            temperature[i],
            mass[i],
            luminosity[i]
        )

        is_convective_list.append(is_conv_value)

    # convert the lists of temperature values to arrays
    is_convective = numpy.array(is_convective_list)

    # ---------- # PLOTTING FUNCTIONS # ---------- #

    # set the plot size
    plt.figure(figsize=(10, 8))

    # plot each of the calculated opacities
    plt.plot(
        norm_radius,
        kappa_es_arr,
        label=r'$\kappa_{e^-}$',
        color="blue",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        kappa_ff_arr,
        label=r'$\kappa_{ff}$',
        color="green",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        kappa_hm_arr,
        label=r'$\kappa_{H^-}$',
        color="red",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        mean_opacity_arr,
        label=r'$\kappa$',
        color="black",
        linestyle="dashed"
    )

    # shade the convective regions
    _shade_convective(x_data=norm_radius, is_convective=is_convective)

    # set the title
    plt.title("Opacity Contributions Plot")

    # set the xlabel
    plt.xlabel(r'Relative Radius ($r / R_{\star}$)')

    # set the ylabel
    plt.ylabel(r'Logarithm of Opacity ($log_{10}(\kappa)$)')

    # set the legend
    plt.legend()

    # render the plot
    plt.show()


def pressure_contribution_plot(stellar_structure, radius, density, temperature, mass, luminosity):
    """
    Function to plot the total pressure and all pressure contributions.

    :param stellar_structure: A module containing the relevant StellarStructure class
        containing the stellar structure equations.
    :param radius: An array of radius values.
    :param density: An array of density values.
    :param temperature: An array of temperature values.
    """

    # extract the StellarStructure class from the inputted `stellar_structure` parameter
    StellarStructure = stellar_structure.StellarStructure()

    # ---------- # CALCULATE THE PRESSURE CONTRIBUTIONS # ---------- #

    # calculate the degeneracy pressure
    deg_pressure = StellarStructure.degeneracy_pressure(density)

    # calculate the gas pressure
    gas_pressure = StellarStructure.gas_pressure(
        density,
        temperature,
        mu=StellarStructure.mean_molec_weight()
    )

    # calculate the photon gas pressure
    photon_pressure = StellarStructure.photon_pressure(temperature)

    # calculate the total pressure
    total_pressure = StellarStructure.total_pressure(density, temperature)

    # ---------- # NORMALIZE THE RADIUS AND PRESSURE DATASETS # ---------- #

    # calculate the surface radius to be used in normalizing the data
    surf_radius = radius[-1]

    # calculate the star's central pressure to be used in normalizing the data
    central_pressure = total_pressure[0]

    # normalize the radius array
    norm_radius = normalize_data(
        in_data=numpy.array([radius]),
        norm_values=[surf_radius]
    )

    # normalize each pressure component array
    norm_pressures = normalize_data(
        in_data=numpy.array([deg_pressure, gas_pressure, photon_pressure, total_pressure]),
        norm_values=[central_pressure, central_pressure, central_pressure, central_pressure]
    )

    # extract the normalized pressures
    norm_deg_pressure = norm_pressures[0]
    norm_gas_pressure = norm_pressures[1]
    norm_photon_pressure = norm_pressures[2]
    norm_total_pressure = norm_pressures[3]

    # ---------- # DETERMINE THE CONVECTIVE REGIONS # ---------- #

    # iterate through the stellar properties obtaining the convective
    # and radiative temperatures at each radius value
    is_convective_list = []
    for i, radius_value in enumerate(radius):
        is_conv_value = StellarStructure.is_convective(
            radius_value,
            density[i],
            temperature[i],
            mass[i],
            luminosity[i]
        )

        is_convective_list.append(is_conv_value)

    # convert the lists of temperature values to arrays
    is_convective = numpy.array(is_convective_list)

    # ---------- # PLOTTING FUNCTIONS # ---------- #

    # set the plot size
    plt.figure(figsize=(10, 8))

    # plot each of the calculated and normalized pressures
    plt.plot(
        norm_radius,
        norm_deg_pressure,
        label="Degeneracy Pressure",
        color="blue",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        norm_gas_pressure,
        label="Gas Pressure",
        color="green",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        norm_photon_pressure,
        label="Photon Pressure",
        color="red",
        linestyle="dashed"
    )
    plt.plot(
        norm_radius,
        norm_total_pressure,
        label="Total Pressure",
        color="black",
        linestyle="solid"
    )

    # add annotations including useful stellar properties (adds context to the normalized data)
    degeneracy_pressure_text = r'$P_{deg, c} = $' + "{} Pa".format(
        format(deg_pressure[0], ".3E")
    )
    gas_pressure_text = r'$P_{gas, c} = $' + "{} Pa".format(
        format(gas_pressure[0], ".3E")
    )
    photon_pressure_text = r'$P_{phot, c} = $' + "{} Pa".format(
        format(photon_pressure[0], ".3E")
    )
    total_pressure_text = r'$P_{tot, c} = $' + "{} Pa".format(
        format(total_pressure[0], ".3E")
    )
    plt.annotate(
        "{}\n{}\n{}\n{}".format(
            degeneracy_pressure_text,
            gas_pressure_text,
            photon_pressure_text,
            total_pressure_text
        ),
        xy=(0.75, 0.4),
        xytext=(0.75, 0.4),
        textcoords="axes fraction")

    # shade the convective regions
    _shade_convective(x_data=norm_radius, is_convective=is_convective)

    # set the title
    plt.title("Pressure Contributions Plot")

    # set the xlabel
    plt.xlabel(r'Relative Radius ($r / R_{\star}$)')

    # set the ylabel
    plt.ylabel(r'Relative Pressure ($P / P_c$)')

    # set the legend
    plt.legend(loc="upper right")

    # render the plot
    plt.show()


def stellar_structure_plot(stellar_structure, radius, density, temperature, mass, luminosity):
    """
    Function to plot normalized stellar density, temperature, mass, and luminosity against radius.

    :param stellar_structure: A module containing the relevant StellarStructure class
        containing the stellar structure equations.
    :param radius: An array of radius values.
    :param density: An array of density values.
    :param temperature: An array of temperature values.
    :param mass: An array of mass values.
    :param luminosity: An array of luminosity values.
    """

    # extract the StellarStructure class from the inputted `stellar_structure` parameter
    StellarStructure = stellar_structure.StellarStructure()

    # ---------- # NORMALIZE THE INPUT DATASETS # ---------- #

    # extract the stellar properties used to normalize the inputted datasets
    surf_radius = radius[-1]
    central_density = density[0]
    central_temp = temperature[0]
    total_mass = mass[-1]
    total_luminosity = luminosity[-1]

    # also get the star's surface temperature
    surf_temp = temperature[-1]

    # normalize the radius data
    norm_radius = normalize_data(
        in_data=numpy.array([radius]),
        norm_values=[surf_radius]
    )

    # normalize the stellar properties data
    norm_state = normalize_data(
        in_data=numpy.array([density, temperature, mass, luminosity]),
        norm_values=[central_density, central_temp, total_mass, total_luminosity]
    )

    # extract the necessary datasets from the normalized state variable
    norm_density = norm_state[0]
    norm_temperature = norm_state[1]
    norm_mass = norm_state[2]
    norm_luminosity = norm_state[3]

    # ---------- # DETERMINE THE CONVECTIVE REGIONS # ---------- #

    # iterate through the stellar properties obtaining the convective
    # and radiative temperatures at each radius value
    is_convective_list = []
    for i, radius_value in enumerate(radius):
        is_conv_value = StellarStructure.is_convective(
            radius_value,
            density[i],
            temperature[i],
            mass[i],
            luminosity[i]
        )

        is_convective_list.append(is_conv_value)

    # convert the lists of temperature values to arrays
    is_convective = numpy.array(is_convective_list)

    # ---------- # PLOTTING FUNCTIONS # ---------- #

    # set the plot size
    plt.figure(figsize=(10, 8))

    # plot the stellar density against stellar radius
    plt.plot(norm_radius, norm_density, label="Density", color="black", linestyle="solid")

    # plot the stellar temperature against stellar radius
    plt.plot(norm_radius, norm_temperature, label="Temperature", color="red", linestyle="dashed")

    # plot the stellar mass against stellar radius
    plt.plot(norm_radius, norm_mass, label="Mass", color="green", linestyle="dashed")

    # plot the stellar luminosity against stellar radius
    plt.plot(norm_radius, norm_luminosity, label="Luminosity", color="blue", linestyle="dotted")

    # add annotations including useful stellar properties to add context
    surface_radius_text = r'$R_{\star, surf} = $' + "{} m = {} ".format(
        format(surf_radius, ".3E"),
        round(surf_radius / r_sun, 3)
    ) + r'$R_{\odot, surf}$'
    central_density_text = r'$\rho_{\star, c} = $' + "{} $kg/m^3$ = {} ".format(
        format(central_density, ".3E"),
        round(central_density / rho_0_sun, 3)
    ) + r'$\rho_{\odot, c}$'
    central_temperature_text = r'$T_{\star, c} = $' + "{} K = {} ".format(
        format(central_temp, ".3E"),
        round(central_temp / T_0_sun, 3)
    ) + r'$T_{\odot, c}$'
    surface_temperature_text = r'$T_{\star, surf} = $' + "{} K = {} ".format(
        format(surf_temp, ".3E"),
        round(surf_temp / T_sun, 3)
    ) + r'$T_{\odot, surf}$'
    total_mass_text = r'$M_{\star} = $' + "{} kg = {} ".format(
        format(total_mass, ".3E"),
        round(total_mass / M_sun, 3)
    ) + r'$M_{\odot}$'
    total_luminosity_text = r'$L_{\star} = $' + "{} W = {} ".format(
        format(total_luminosity, ".3E"),
        round(total_luminosity / L_sun, 3)
    ) + r'$L_{\odot}$'
    plt.annotate(
        "{}\n{}\n{}\n{}\n{}\n{}".format(
            surface_radius_text,
            central_density_text,
            central_temperature_text,
            surface_temperature_text,
            total_mass_text,
            total_luminosity_text
        ),
        xy=(0.6, 0.4),
        xytext=(0.6, 0.4),
        textcoords="axes fraction")

    # shade in the areas where convective forces dominate
    _shade_convective(x_data=norm_radius, is_convective=is_convective)

    # set the title
    plt.title("Stellar Structure Plot")

    # set the xlabel
    plt.xlabel(r'Relative Radius ($r / R_{\star}$)')

    # set the ylabel
    plt.ylabel(r'$\rho / \rho_c$, $T / T_c$, $M / M_{\star}$, $L / L_{\star}$')

    # set the legend
    plt.legend(loc="upper right")

    # render the plot
    plt.show()


# ---------- # STELLAR AND STELLAR SEQUENCE PLOTTING FUNCTIONS # ---------- #

def plot_star(stellar_structure, radius, density, temperature, mass, luminosity):
    """
    Function to execute all the plotting functions pertaining to the generation of a single star.

    :param stellar_structure: A module containing the relevant StellarStructure class
        containing the stellar structure equations.
    :param radius: An array of radius values.
    :param density: An array of density values.
    :param temperature: An array of temperature values.
    :param mass: An array of mass values.
    :param luminosity: An array of luminosity values.
    """

    # plot the complete stellar structure plot
    stellar_structure_plot(
        stellar_structure=stellar_structure,
        radius=radius,
        density=density,
        temperature=temperature,
        mass=mass,
        luminosity=luminosity
    )

    # plot the pressure contributions
    pressure_contribution_plot(
        stellar_structure=stellar_structure,
        radius=radius,
        density=density,
        temperature=temperature,
        mass=mass,
        luminosity=luminosity
    )

    # plot the luminosity contributions
    luminosity_contribution_plot(
        stellar_structure=stellar_structure,
        radius=radius,
        density=density,
        temperature=temperature,
        mass=mass,
        luminosity=luminosity
    )

    # plot the logarithm of the opacity contributions
    opacity_contribution_plot(
        stellar_structure=stellar_structure,
        radius=radius,
        density=density,
        temperature=temperature,
        mass=mass,
        luminosity=luminosity
    )


def plot_sequence(temperatures, luminosities):
    """
    Function to execute all the plotting functions pertaining to the generation
    of a stellar sequence.

    :param temperatures: An array of the surface temperature values of each star in a sequence.
    :param luminosities: An array of the total luminosity values of each star in a sequence.
    """

    # plot the Hertzsprung-Russell diagram
    hr_diagram(
        effect_temps=temperatures,
        luminosities=luminosities
    )
