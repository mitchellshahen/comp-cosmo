"""
Module to define the stellar structure equations that govern stellar bodies.

:title: stellar_structure.py

:author: Mitchell Shahen

:history: 05/05/2021
"""

import numpy
import sys
sys.path.append("../") # be able to access the base directory

from base.constants import a, c, G, gamma, h_bar, k, m_e, m_p
import base.units as units

# include the mass fractions for the Sun to be used as defaults
X_sun = 0.7381
Y_sun = 0.2485
Z_sun = 0.0134

# include the indices for the state and derivative state arrays
rho_index = 0
T_index = 1
M_index = 2
L_index = 3
tau_index = 4


class StellarStructure:
    """
    Class object to define and solve the stellar structure equations.
    """

    def __init__(self, X=X_sun, Y=Y_sun, Z=Z_sun):
        """
        Constructor class object for the StellarStructure class.

        :param X: The mass fraction of hydrogen in the star. Defaults to the hydrogen mass fraction of the Sun.
        :param Y: The mass fraction of helium in the star. Defaults to the helium mass fraction of the Sun.
        :param Z: The mass fraction of remaining materials in the star. Defaults to the mass
            fraction of remaining materials in the Sun.
        """

        # ensure that the inputted mass fractions sum to 1 (to some negligible error)
        if not all(
                [
                    X + Y + Z >= 0.9999,
                    X + Y + Z <= 1.0001
                ]
        ):
            raise IOError("The inputted mass fractions, X, Y, and Z must sum to 1.")

        # set the mass fraction of hydrogen
        self.X = X

        # set the mass fraction of helium
        self.Y = Y

        # set the mass fraction of the remaining elements
        self.Z = Z

    def initial_properties(self, r_0, rho_0, T_0):
        """
        Method to define the initial values used to solve the stellar structure equations.

        :param r_0: The initial radius value used in solving the stellar structure equations.
        :param rho_0: The central density of the star.
        :param T_0: The central temperature of the star.
        :returns: A numpy ndarray of the initial stellar properties: central density, central temperature,
            initial mass, initial radiative luminosity, and initial optical density.
        """

        # set the mass contained within a sphere of very small radius
        M_0 = 4 * numpy.pi * (r_0 ** 3) * rho_0 / 3

        # set the luminosity generated by a sphere of very small radius
        L_0 = 4 * numpy.pi * (r_0 ** 3) * rho_0 * self.energy_gen_rate(rho=rho_0, T=T_0) / 3

        # set the initial optical density
        tau_0 = self.mean_opacity(rho=rho_0, T=T_0) * rho_0

        # amalgamate all the state variables into a single array
        initial_state = numpy.array([rho_0, T_0, M_0, L_0, tau_0])

        return initial_state

    def get_derivative_state(self, r, state):
        """
        Method to set up and acquire the derivatives of the state variables: density, temperature,
        mass, luminosity, and optical depth at a given radius.

        :param r: A radius at which the derivatives of various stellar properties are required.
        :param state: A matrix containing 5 arrays: the density array, temperature array, mass
            array, luminosity array, and optical depth array.
        :return: A matrix of 5 arrays containing the radial derivatives of density, temperature,
            mass, luminosity, and optical depth, respectively, all evaluated at `r`.
        """

        # extract from the input state the necessary variables
        rho = state[rho_index]
        T = state[T_index]
        M = state[M_index]
        L = state[L_index]

        # ensure no state values are 0
        if any(
            [rho <= 0, T <= 0, M <= 0, L <= 0]
        ):
            raise ArithmeticError(
                "ERROR: Encountered a zero or negative state variable in the process of "
                "integrating the stellar structure equations."
            )

        # get the density derivative
        drho_dr = self.hydrostat_equil(r=r, rho=rho, T=T, M=M, L=L)

        # get the temperature derivative
        dT_dr = self.temperature_grad(r=r, rho=rho, T=T, M=M, L=L)

        # get the mass derivative
        dM_dr = self.mass_continuity(r=r, rho=rho)

        # get the luminosity derivative
        dL_dr = self.energy_equation(r=r, rho=rho, T=T)

        # get the optical depth derivative
        dtau_dr = self.optical_depth_equation(rho=rho, T=T)

        # set up the state variable
        deriv_state = numpy.array([drho_dr, dT_dr, dM_dr, dL_dr, dtau_dr])

        return deriv_state

    # ---------- # ANCILLARY CONSTANTS # ---------- #

    def energy_gen_rate(self, rho, T, X_cno=None):
        """
        Method to calculate the total energy generation rate from the PP-chain and the CNO cycle.

        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param X_cno: The mass fraction of hydrogen due to the CNO cycle.
        """

        # set the CNO abundance value
        if any(
                [
                    X_cno is None,
                    not isinstance(X_cno, (int, float))
                ]
        ):
            # if the included CNO abundance is invalid, use the solar CNO abundance
            X_cno = 0.03 * self.X

        # set the scaled density value
        rho_5 = rho / (10 ** 5)

        # set the scaled temperature value
        T_6 = T / (10 ** 6)

        # calculate the energy generation rate from the PP-chain
        epsilon_pp = (1.07e-7 * (units.W / units.kg)) * rho_5 * (self.X ** 2) * (T_6 ** 4)

        # calculate the energy generate rate from the CNO cycle
        epsilon_cno = (8.24e-26 * (units.W / units.kg)) * rho_5 * self.X * X_cno * (T_6 ** 19.9)

        # calculate the total energy generate rate
        epsilon_total = epsilon_pp + epsilon_cno

        return epsilon_total

    def mean_molec_weight(self):
        """
        Method to calculate the mean molecular weight as a function of the mass fractions.

        :returns: The mean molecular weight.
        """

        mu_total = (2 * self.X + 0.75 * self.Y + 0.5 * self.Z) ** -1

        return mu_total

    def mean_opacity(self, rho, T):
        """
        Method to calculate the Rossland mean opacities from three dominant processes:
            - Electron scattering
            - Free-free scattering (a Kramer-like approximation)
            - H-minus scattering at low temperatures

        :param rho: The stellar density.
        :param T: The stellar temperature.
        :returns: The Rossland mean opacity.
        """

        # set the scaled density value
        rho_3 = rho / (10 ** 3)

        # calculate the mean opacity from electron scattering
        kappa_es_coeff = 0.02 * (units.m ** 2 / units.kg)
        kappa_es = kappa_es_coeff * (1 + self.X)

        # calculate the mean opacity from free-free scattering
        kappa_ff_coeff = 1.0e24 * (units.m ** 2 / units.kg)
        kappa_ff = kappa_ff_coeff * (self.Z + 0.0001) * (rho_3 ** 0.7) * (T ** (-7/2))

        # calculate the mean opacity from H-minus scattering
        kappa_hm_coeff = 2.5e-32 * (units.m ** 2 / units.kg)
        kappa_hm = kappa_hm_coeff * (self.Z / 0.02) * (rho_3 ** 0.5) * (T ** 9)

        # calculate the total mean opacity
        kappa_total = ((1 / kappa_hm) + (1 / max(kappa_es, kappa_ff))) ** (-1)

        return kappa_total

    # ---------- # THERMODYNAMIC VARIABLES # ---------- #

    @staticmethod
    def degeneracy_pressure(rho):
        """
        Method to calculate the pressure of each relevant equation of state using a given density
        and temperature.

        :param rho: The stellar density.
        :returns: The degeneracy pressure in a stellar body.
        """

        # calculate the non-relativistic degeneracy pressure
        pressure_deg = ((3 * numpy.pi ** 2) ** (2 / 3)) * (h_bar ** 2) * ((rho / m_p) ** (5 / 3)) / (5 * m_e)

        return pressure_deg

    @staticmethod
    def gas_pressure(rho, T, mu=1.0):
        """
        Method to calculate the pressure of each relevant equation of state using a given density
        and temperature.

        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param mu: The mean molecular weight.
        :returns: The pressure in a stellar body due to gaseous contributions.
        """

        # calculate the pressure generated by ideal gases
        pressure_gas = rho * k * T / (mu * m_p)

        return pressure_gas

    @staticmethod
    def photon_pressure(T):
        """
        Method to calculate the pressure of each relevant equation of state using a given density
        and temperature.

        :param T: The stellar temperature.
        :returns: The pressure in a stellar body due to photon gas contributions.
        """

        # calculate the photon gas pressure
        pressure_photon = a * (T ** 4) / 3

        return pressure_photon

    def total_pressure(self, rho, T):
        """
        Method to calculate the pressure of each relevant equation of state using a given density
        and temperature.

        :param rho: The stellar density.
        :param T: The stellar temperature.
        :returns: The total pressure in a stellar body.
        """

        # calculate the non-relativistic degeneracy pressure
        pressure_deg = self.degeneracy_pressure(rho)

        # calculate the pressure generated by ideal gases
        pressure_gas = self.gas_pressure(rho, T, mu=self.mean_molec_weight())

        # calculate the photon gas pressure
        pressure_photon = self.photon_pressure(T)

        # calculate the total pressure as the sum of all the pressure components
        total_pressure = pressure_deg + pressure_gas + pressure_photon

        return total_pressure

    def temp_convective(self, r, rho, T, M):
        """
        Method to calculate the temperature due to convective contributions:
            convective temperature = (1 - 1/lambda) * T * G * M * rho / (P * r ** 2)

        :param r: The radius value for which the density, temperature, and cumulative mass correspond.
        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param M: The cumulative mass contained within a radius, `r`.
        :returns: The temperature due to convective contributions.
        """

        # get the total pressure
        pressure = self.total_pressure(rho=rho, T=T)

        # calculate the convective temperature gradient
        T_convective = (1 - 1 / gamma) * T * G * M * rho / (pressure * (r ** 2))

        return T_convective

    def temp_radiative(self, r, rho, T, L):
        """
        Method to calculate the temperature due to radiative contributions:
            radiative temperature = 3 * kappa * rho * L / (16 * pi * a * c * T ** 3 * r ** 2)

        :param r: The radius value for which the density, temperature, and cumulative luminosity correspond.
        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param L: The cumulative luminosity radiated by the star, but considering contributions
            from inside a radius, `r`.
        :returns: The temperature due to radiative contributions.
        """

        # get the total mean opacity
        opacity = self.mean_opacity(rho=rho, T=T)

        # calculate the radiative temperature
        T_radiative = 3 * opacity * rho * L / (16 * numpy.pi * a * c * (T ** 3) * (r ** 2))

        return T_radiative

    # ---------- # DIFFERENTIAL EQUATIONS # ---------- #

    def hydrostat_equil(self, r, rho, T, M, L):
        """
        Method to define the hydrostatic equilibrium differential equation:
            drho/dr = - ((G * M * rho / r**2) + (dP/dT * dT/dr)) / (dP / drho)
        Note: The pressure-density and pressure-temperature differentials are calculated by
            differentiating the total pressure equation included in the `total_pressure` docstring
            as the sum of the non-relativistic degenerate pressure, the ideal gas pressure, and
            the photon gas pressure.

        :param r: The radius value for which the density, temperature, cumulative mass, and
            cumulative luminosity correspond.
        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param M: The cumulative mass contained within a radius, `r`.
        :param L: The cumulative luminosity radiated by the star, but considering contributions
            from inside a radius, `r`.
        :returns: The density derivative with respect to the radial component.
        """

        # calculate the pressure-temperature differential
        dP_dT = (rho * k / (self.mean_molec_weight() * m_p)) + (4 * a * (T ** 3) / 3)

        # calculate the pressure density differential
        deg_pressure_diff = ((3 * (numpy.pi ** 2)) ** (2/3)) * (h_bar ** 2) * ((rho / m_p) ** (2/3)) / (3 * m_e * m_p)
        ideal_pressure_diff = (k * T) / (self.mean_molec_weight() * m_p)
        dP_drho = deg_pressure_diff + ideal_pressure_diff

        # calculate the temperature-radius differential
        dT_dr = self.temperature_grad(r=r, rho=rho, T=T, M=M, L=L)

        # calculate the density gradient
        density_gradient = -1.0 * (
            (G * M * rho / (r ** 2)) + (dP_dT * dT_dr)
        ) / (dP_drho)

        return density_gradient

    def temperature_grad(self, r, rho, T, M, L):
        """
        Method to define the temperature gradient differential equation:
            dT/dr = - min(radiative temperature, convective temperature)

        :param r: The radius value for which the density, temperature, cumulative mass, and
            cumulative luminosity correspond.
        :param rho: The stellar density.
        :param T: The stellar temperature.
        :param M: The cumulative mass contained within a radius, `r`.
        :param L: The cumulative luminosity radiated by the star, but considering contributions
            from inside a radius, `r`.
        :returns: The temperature derivative with respect to the radial component.
        """

        # calculate the radiative temperature gradient
        T_radiative = self.temp_radiative(r=r, rho=rho, T=T, L=L)

        # calculate the convective temperature gradient
        T_convective = self.temp_convective(r=r, rho=rho, T=T, M=M)

        # calculate the temperature gradient
        temp_gradient = -1.0 * min(T_convective, T_radiative)

        return temp_gradient

    @staticmethod
    def mass_continuity(r, rho):
        """
        Method to define the mass continuity differential equation:
            dM/dr = 4 * pi * r**2 * rho

        :param r: The radius value for which the density correspond.
        :param rho: The stellar density.
        :returns: The mass derivative with respect to the radial component.
        """

        # calculate the mass gradient
        mass_gradient = 4 * numpy.pi * rho * (r ** 2)

        return mass_gradient

    def energy_equation(self, r, rho, T):
        """
        Method to define the energy differential equation:
            dL/dr = 4 * pi * r**2 * rho * epsilon

        :param r: The radius value for which the density and temperature correspond.
        :param rho: The stellar density.
        :param T: The stellar temperature.
        :returns: The luminosity derivative with respect to the radial component.
        """

        # obtain the energy generation rate necessary for defining the stellar luminosity
        energy_gen = self.energy_gen_rate(rho=rho, T=T, X_cno=None)

        # calculate the luminosity gradient
        lumin_gradient = 4 * numpy.pi * rho * energy_gen * (r ** 2)

        return lumin_gradient

    def optical_depth_equation(self, rho, T):
        """
        Method to define the optical depth differential equation:
            dtau/dr = kappa * rho

        :param rho: The stellar density.
        :param T: The stellar temperature.
        :returns: The density derivative with respect to the radial component.
        """

        # calculate the optical depth differential
        opt_depth_gradient = self.mean_opacity(rho=rho, T=T) * rho

        return opt_depth_gradient
