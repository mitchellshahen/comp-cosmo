"""
Module to define the stellar structure equations that govern stellar bodies.
"""

import constants
import numpy
import units

# include the mass fractions for the Sun as the defaults
X_sun = 0.7381
Y_sun = 0.2485
Z_sun = 0.0134

# include the indices for the state and derivative state arrays
rho_index = 0
T_index = 1
M_index = 2
L_index = 3
tau_index = 4


class StellarStructure:
    """
    Class object to define and solve the stellar structure equations.
    """

    def __init__(self, X=X_sun, Y=Y_sun, Z=Z_sun):
        """
        Constructor class object for the StellarStructure class.
        """

        # ensure that the inputted mass fractions sum to 1 (to some negligible error)
        if not all(
                [
                    X + Y + Z >= 0.999,
                    X + Y + Z <= 1.001
                ]
        ):
            raise IOError("The inputted mass fractions, X, Y, and Z must sum to 1.")

        # set the mass fraction of hydrogen
        self.X = X

        # set the mass fraction of helium
        self.Y = Y

        # set the mass fraction of the remaining elements
        self.Z = Z

    def initial_properties(self, r_0, rho_0, T_0):
        """
        Method to define the initial values used to solve the stellar structure equations.
        """

        # set the mass contained within a sphere of very small radius
        M_0 = 4 * numpy.pi * (r_0 ** 3) * rho_0 / 3

        # set the luminosity generated by a sphere of very small radius
        L_0 = 4 * numpy.pi * (r_0 ** 3) * rho_0 * self.energy_gen_rate(rho=rho_0, T=T_0) / 3

        # set the initial optical density
        tau_0 = self.mean_opacity(rho=rho_0, T=T_0) * rho_0

        # amalgamate all the state variables into a single array
        initial_state = numpy.array([rho_0, T_0, M_0, L_0, tau_0])

        return initial_state

    def get_derivative_state(self, r, state):
        """
        Method to set up and acquire the derivatives of the state variables: density, temperature,
        mass, luminosity, and optical depth at a given radius.

        :param r: A radius at which the derivatives of various stellar properties are required.
        :param state: A matrix containing 5 arrays: the density array, temperature array, mass
            array, luminosity array, and optical depth array.
        :return: A matrix of 5 arrays containing the radial derivatives of density, temperature,
            mass, luminosity, and optical depth, respectively, all evaluated at `r`.
        """

        # extract from the input state the necessary variables
        rho, T, M, L, tau = state

        # get the density derivative
        drho_dr = self.hydrostat_equil(r=r, rho=rho, T=T, M=M, L=L)

        # get the temperature derivative
        dT_dr = self.temperature_grad(r=r, rho=rho, T=T, M=M, L=L)

        # get the mass derivative
        dM_dr = self.mass_continuity(r=r, rho=rho)

        # get the luminosity derivative
        dL_dr = self.energy_equation(r=r, rho=rho, T=T)

        # get the optical depth derivative
        dtau_dr = self.optical_depth_equation(rho=rho, T=T)

        # set up the state variable
        deriv_state = numpy.array([drho_dr, dT_dr, dM_dr, dL_dr, dtau_dr])

        return deriv_state

    # ---------- # ANCILLARY CONSTANTS # ---------- #

    def energy_gen_rate(self, rho, T, X_cno=None):
        """
        Method to calculate the total energy generation rate from the PP-chain and the CNO cycle.
        """

        # set the CNO abundance value
        if any(
                [
                    X_cno <= 0.0,
                    X_cno is None,
                    not isinstance(X_cno, (int, float))
                ]
        ):
            # if the included CNO abundance is invalid, use the solar CNO abundance
            X_cno = 0.03 * self.X

        # set the scaled density value
        rho_5 = rho / (10 ** 5)

        # set the scaled temperature value
        T_6 = T / (10 ** 6)

        # calculate the energy generation rate from the PP-chain
        epsilon_pp = (1.07e-7 * (units.W / units.kg)) * rho_5 * (self.X ** 2) * (T_6 ** 4)

        # calculate the energy generate rate from the CNO cycle
        epsilon_cno = (8.24e-26 * (units.W / units.kg)) * rho_5 * self.X * X_cno * (T_6 ** 19.9)

        # calculate the total energy generate rate
        epsilon_total = epsilon_pp + epsilon_cno

        return epsilon_total

    def mean_molec_weight(self):
        """
        Method to calculate the mean molecular weight as a function of the mass fractions.
        """

        mu_total = (2 * self.X + 0.75 * self.Y + 0.5 * self.Z) ** -1

        return mu_total

    def mean_opacity(self, rho, T):
        """
        Method to calculate the Rossland mean opacities from three dominant processes:
            - Electron scattering
            - Free-free scattering (a Kramer-like approximation)
            - H-minus scattering at low temperatures
        """

        # set the scaled density value
        rho_3 = rho / (10 ** 3)

        # calculate the mean opacity from electron scattering
        kappa_es_coeff = 0.02 * (units.m ** 2 / units.kg)
        kappa_es = kappa_es_coeff * (1 + self.X)

        # calculate the mean opacity from free-free scattering
        kappa_ff_coeff = 1.0e24 * (units.m ** 2 / units.kg)
        kappa_ff = kappa_ff_coeff * (self.Z + 0.0001) * (rho_3 ** 0.7) * (T ** (-7/2))

        # calculate the mean opacity from H-minus scattering
        kappa_hm_coeff = 2.5e-32 * (units.m ** 2 / units.kg)
        kappa_hm = kappa_hm_coeff * (self.Z / 0.02) * (rho_3 ** 0.5) * (T ** 9)

        # calculate the total mean opacity
        kappa_total = ((1 / kappa_hm) + (1 / max(kappa_es, kappa_ff))) ** -1

        return kappa_total

    # ---------- # THERMODYNAMIC VARIABLES # ---------- #

    def total_pressure(self, rho, T):
        """
        Method to calculate the pressure of each relevant equation of state using a given density
        and temperature.
        """

        # calculate the non-relativistic degeneracy pressure
        pressure_degeneracy = (
            (3 * numpy.pi ** 2) ** (2 / 3)
        ) * (constants.h_bar ** 2) * (
            (rho / constants.m_p) ** (5 / 3)
        ) / (5 * constants.m_e)

        # calculate the pressure generated by ideal gases
        pressure_gas = rho * constants.k * T / (self.mean_molec_weight() * constants.m_p)

        # calculate the photon gas pressure
        pressure_photon = constants.a * (T ** 4) / 3

        # calculate the total pressure as the sum of all the pressure components
        total_pressure = pressure_degeneracy + pressure_gas + pressure_photon

        return total_pressure

    def temp_convective(self, r, rho, T, M):
        """
        Method to calculate the temperature due to convective contributions:
            convective temperature = (1 - 1/lambda) * T * G * M * rho / (P * r ** 2)
        """

        # get the total pressure
        pressure = self.total_pressure(rho=rho, T=T)

        # calculate the convective temperature gradient
        T_convective = (1 - 1 / constants.gamma) * T * constants.G * M * rho / (pressure * (r ** 2))

        return T_convective

    def temp_radiative(self, r, rho, T, L):
        """
        Method to calculate the temperature due to radiative contributions:
            radiative temperature = 3 * kappa * rho * L / (16 * pi * a * c * T ** 3 * r ** 2)
        """

        # get the total mean opacity
        opacity = self.mean_opacity(rho=rho, T=T)

        # calculate the radiative temperature
        T_radiative = 3 * opacity * rho * L / (
            16 * numpy.pi * constants.a * constants.c * (T ** 3) * (r ** 2)
        )

        return T_radiative

    # ---------- # DIFFERENTIAL EQUATIONS # ---------- #

    def hydrostat_equil(self, r, rho, T, M, L):
        """
        Method to define the hydrostatic equilibrium differential equation:
            drho/dr = - ((G * M * rho / r**2) + (dP/dT * dT/dr)) / (dP / drho)
        Note: The pressure-density and pressure-temperature differentials are calculated by
            differentiating the total pressure equation included in the `total_pressure` docstring
            as the sum of the non-relativistic degenerate pressure, the ideal gas pressure, and
            the photon gas pressure.
        """

        # calculate the pressure-temperature differential
        dP_dT = (
            rho * constants.k / (self.mean_molec_weight() * constants.m_p)
        ) + (
            4 * constants.a * (T ** 3) / 3
        )

        # calculate the pressure density differential
        deg_pressure_diff = (
            (3 * (numpy.pi ** 2)) ** (2/3)
        ) * (
            constants.h_bar ** 2
        ) * (
            (rho / constants.m_p) ** (2/3)
        ) / (
            3 * constants.m_e * constants.m_p
        )
        ideal_pressure_diff = (
            constants.k * T
        ) / (
            self.mean_molec_weight() * constants.m_p
        )
        dP_drho = deg_pressure_diff + ideal_pressure_diff

        # calculate the temperature-radius differential
        dT_dr = self.temperature_grad(r=r, rho=rho, T=T, M=M, L=L)

        # calculate the density gradient
        density_gradient = -1.0 * (
            (constants.G * M * rho / (r ** 2)) + (dP_dT * dT_dr)
        ) / (dP_drho)

        return density_gradient

    def temperature_grad(self, r, rho, T, M, L):
        """
        Method to define the temperature gradient differential equation:
            dT/dr = - min(radiative temperature, convective temperature)
        """

        # calculate the radiative temperature gradient
        T_radiative = self.temp_radiative(r=r, rho=rho, T=T, L=L)

        # calculate the convective temperature gradient
        T_convective = self.temp_convective(r=r, rho=rho, T=T, M=M)

        # calculate the temperature gradient
        temp_gradient = -1.0 * min(T_convective, T_radiative)

        return temp_gradient

    @staticmethod
    def mass_continuity(r, rho):
        """
        Method to define the mass continuity differential equation:
            dM/dr = 4 * pi * r**2 * rho
        """

        # calculate the mass gradient
        mass_gradient = 4 * numpy.pi * rho * (r ** 2)

        return mass_gradient

    def energy_equation(self, r, rho, T):
        """
        Method to define the energy differential equation:
            dL/dr = 4 * pi * r**2 * rho * epsilon
        """

        # obtain the energy generation rate necessary for defining the stellar luminosity
        energy_gen = self.energy_gen_rate(rho=rho, T=T, X_cno=None)

        # calculate the luminosity gradient
        lumin_gradient = 4 * numpy.pi * rho * energy_gen * (r ** 2)

        return lumin_gradient

    def optical_depth_equation(self, rho, T):
        """
        Method to define the optical depth differential equation:
            dtau/dr = kappa * rho
        """

        # calculate the optical depth differential
        opt_depth_gradient = self.mean_opacity(rho=rho, T=T) * rho

        return opt_depth_gradient
